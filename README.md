
Отчёт 
Проект «Блогикум». Часть 3. Доработка
________________________________________
1. Представление моделей в административной панели
1.1 Регистрация моделей в admin.py
Файл: blogicum/blog/admin.py
В административной панели Django зарегистрированы модели:
•	Category
•	Location
•	Post
•	Comment
Для каждой модели настроен собственный класс администратора, определяющий:
•	отображаемые поля (list_display);
•	фильтрацию (list_filter);
•	поиск (search_fields).
Для модели Comment реализованы два способа отображения:
1.	Как отдельная модель в админке — для централизованной модерации комментариев.
2.	Как TabularInline внутри PostAdmin — для удобного управления комментариями прямо со страницы поста.
Пояснение:
Такой подход позволяет администратору как быстро редактировать комментарии внутри конкретного поста, так и управлять всеми комментариями проекта в одном месте.
________________________________________
2. Модели и связи между ними
2.1 Использование ForeignKey и on_delete
Файл: blogicum/blog/models.py
Во всех моделях, использующих связи ForeignKey, явно указан параметр on_delete:
•	CASCADE — для связей, где логично удалять зависимые объекты
(посты и комментарии пользователя, комментарии поста);
•	SET_NULL — для категорий и локаций, чтобы при их удалении посты не исчезали.
Пояснение:
Такое поведение предотвращает потерю данных и соответствует логике предметной области.
________________________________________
2.2 related_name и доступ через поля связи
Для всех связей заданы параметры related_name, что позволяет получать связанные объекты через поля связи:
•	author.posts — посты пользователя;
•	post.comments — комментарии поста;
•	category.post_set — посты категории.
Пояснение:
Использование полей связи является рекомендуемым подходом Django и повышает читаемость и производительность кода.
________________________________________
3. Формы
Файл: blogicum/blog/forms.py
Для работы с данными используются ModelForm.
Форма поста настраивается через exclude, а не fields:
exclude = ('author', 'created_at')
Пояснение:
•	поле author задаётся программно в представлении;
•	поле created_at не должно редактироваться пользователем;
•	остальные поля (включая is_published и pub_date) доступны автору для управления публикацией.
________________________________________
4. Маршруты и URL
Файл: blogicum/blog/urls.py
В маршрутах используются содержательные имена параметров:
•	post_id
•	comment_id
•	category_slug
•	username
Для имени пользователя используется тип str, а не slug.
Пояснение:
slug имеет ограничения по символам, тогда как username может содержать более широкий набор символов.
________________________________________
5. Использование именованных маршрутов
Во всех частях проекта URL формируются только через имена маршрутов:
•	в представлениях — с помощью reverse() и redirect();
•	в шаблонах — с помощью тега {% url %}.
Пояснение:
Это исключает жёстко заданные URL и позволяет безопасно изменять маршруты без правок в логике и шаблонах.
________________________________________
6. Получение объектов через get_object_or_404
Во всех представлениях получение объектов из базы данных выполняется исключительно через get_object_or_404().
Пояснение:
Это гарантирует корректную обработку ситуации, когда объект не найден, и автоматически возвращает HTTP 404.
________________________________________
7. Подсчёт комментариев и оптимизация запросов
7.1 Аннотация комментариев
Файл: blogicum/blog/views.py
Для подсчёта количества комментариев используется единая функция:
def get_posts_metadata(queryset=None, is_author=False):
    ...
    return queryset.annotate(
        comment_count=Count('comments')
    ).order_by('-pub_date')
Пояснение:
Подсчёт комментариев выполняется на уровне ORM с помощью annotate(), а не в шаблонах.
Это исключает N+1 запросы и повышает производительность.
________________________________________
7.2 Отказ от .count() в шаблонах
В шаблонах используется поле comment_count, переданное из queryset.
Прямой вызов comments.count в шаблонах не применяется.
________________________________________
8. Пагинация
Логика пагинации вынесена в отдельную функцию:
def get_page_obj(request, queryset, per_page=10):
    ...
Пояснение:
Вынесение пагинации в функцию позволяет использовать единый подход на всех страницах проекта и уменьшает дублирование кода.
________________________________________
9. Зависимость набора постов от пользователя
На странице профиля набор отображаемых постов зависит от посетителя:
•	автор видит все свои посты, включая неопубликованные;
•	остальные пользователи — только опубликованные.
Это реализовано через параметр is_author в функции get_posts_metadata.
________________________________________
10. Детальный просмотр поста и проверка прав доступа
В PostDetailView реализована двухэтапная проверка доступа:
1.	Пост извлекается для определения автора.
2.	Если пользователь не является автором, выполняется дополнительная проверка опубликованности.
Пояснение:
Это предотвращает доступ к неопубликованным постам для посторонних пользователей.
________________________________________
11. Ограничение доступа для анонимных пользователей
Для представлений создания, редактирования и удаления используются:
•	LoginRequiredMixin;
•	проверки авторства в dispatch.
Пояснение:
Анонимные пользователи не могут изменять данные, а автор может управлять только своими постами и комментариями.
________________________________________
12. Репозиторий и .gitignore
В файле .gitignore исключены директории:
static/
static-dev/
html/
Пояснение:
Статические и служебные файлы не должны храниться в репозитории.


